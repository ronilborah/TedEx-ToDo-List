"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/view/page",{

/***/ "(app-pages-browser)/./hooks/useTasksAPI.ts":
/*!******************************!*\
  !*** ./hooks/useTasksAPI.ts ***!
  \******************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   useTasks: () => (/* binding */ useTasks)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(app-pages-browser)/../node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n// ========================================\n// API INTEGRATION - ENABLED\n// ========================================\n// This file provides backend API integration for task persistence\n// Tasks are now stored in MongoDB instead of localStorage\n\nconst TASKS_KEY = \"taskManagerTasks\";\nfunction loadTasksFromStorage() {\n    try {\n        const data = localStorage.getItem(TASKS_KEY);\n        if (!data) return [];\n        const parsed = JSON.parse(data);\n        return parsed.map((task)=>({\n                ...task,\n                createdAt: new Date(task.createdAt),\n                dueDate: task.dueDate ? new Date(task.dueDate) : undefined\n            }));\n    } catch (e) {\n        return [];\n    }\n}\nfunction saveTasksToStorage(tasks) {\n    localStorage.setItem(TASKS_KEY, JSON.stringify(tasks));\n}\nfunction useTasks() {\n    const [tasks, setTasks] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)([]);\n    const [loading, setLoading] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(true);\n    const [error, setError] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)({\n        \"useTasks.useEffect\": ()=>{\n            setLoading(true);\n            try {\n                setTasks(loadTasksFromStorage());\n                setError(null);\n            } catch (err) {\n                setError(\"Failed to load tasks\");\n            } finally{\n                setLoading(false);\n            }\n        }\n    }[\"useTasks.useEffect\"], []);\n    const save = (newTasks)=>{\n        setTasks(newTasks);\n        saveTasksToStorage(newTasks);\n    };\n    const addTask = (taskData)=>{\n        const newTask = {\n            ...taskData,\n            id: Math.random().toString(36).slice(2),\n            createdAt: new Date(),\n            completed: false\n        };\n        save([\n            newTask,\n            ...tasks\n        ]);\n        return newTask.id;\n    };\n    const updateTask = (id, taskData)=>{\n        save(tasks.map((task)=>task.id === id ? {\n                ...task,\n                ...taskData\n            } : task));\n    };\n    const toggleComplete = (id)=>{\n        save(tasks.map((task)=>task.id === id ? {\n                ...task,\n                completed: !task.completed\n            } : task));\n    };\n    const deleteTask = (id)=>{\n        save(tasks.filter((task)=>task.id !== id));\n    };\n    const getTask = (id)=>tasks.find((task)=>task.id === id);\n    const getStats = ()=>{\n        const total = tasks.length;\n        const completed = tasks.filter((t)=>t.completed).length;\n        const pending = tasks.filter((t)=>!t.completed && t.status !== \"Done\").length;\n        const overdue = tasks.filter((t)=>!t.completed && t.dueDate && t.dueDate < new Date()).length;\n        const completionRate = total ? completed / total : 0;\n        return {\n            total,\n            completed,\n            pending,\n            overdue,\n            completionRate\n        };\n    };\n    return {\n        tasks,\n        loading,\n        error,\n        addTask,\n        updateTask,\n        toggleComplete,\n        deleteTask,\n        getTask,\n        getStats,\n        refreshTasks: ()=>setTasks(loadTasksFromStorage())\n    };\n} // ========================================\n // MIGRATION INSTRUCTIONS\n // ========================================\n // To migrate from localStorage to API:\n // 1. Uncomment the code above\n // 2. Replace the existing useTasks hook in your components:\n //    - In app/tasks/page.tsx: Replace useTasks() with useTasksAPI()\n //    - In app/add/page.tsx: Replace useTasks() with useTasksAPI()\n //    - In app/edit/[id]/page.tsx: Replace useTasks() with useTasksAPI()\n // 3. Update environment variables:\n //    - Add NEXT_PUBLIC_API_URL=http://localhost:6900/api to your .env file\n // 4. Handle loading states:\n //    - The API version includes loading and error states\n //    - Add loading spinners and error messages to your UI\n // 5. Test the integration:\n //    - Start both frontend and backend: npm run dev (from root)\n //    - Verify tasks are saved to MongoDB instead of localStorage\n // ========================================\n // EXAMPLE USAGE\n // ========================================\n /*\nfunction TasksPage() {\n  const { \n    tasks, \n    loading, \n    error, \n    addTask, \n    updateTask, \n    toggleComplete, \n    deleteTask \n  } = useTasksAPI()\n\n  if (loading) return <div>Loading tasks...</div>\n  if (error) return <div>Error: {error}</div>\n\n  return (\n    <div>\n      {tasks.map(task => (\n        <TaskCard\n          key={task.id}\n          task={task}\n          onToggleComplete={toggleComplete}\n          onEdit={(id) => router.push(`/edit/${id}`)}\n          onDelete={deleteTask}\n        />\n      ))}\n    </div>\n  )\n}\n*/ \n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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TSxLQUFLLFFBQVFILE1BQU07UUFDN0UsTUFBTUksVUFBVWpDLE1BQU13QixNQUFNLENBQUNNLENBQUFBLElBQUssQ0FBQ0EsRUFBRVYsU0FBUyxJQUFJVSxFQUFFakMsT0FBTyxJQUFJaUMsRUFBRWpDLE9BQU8sR0FBRyxJQUFJRCxRQUFRaUMsTUFBTTtRQUM3RixNQUFNSyxpQkFBaUJOLFFBQVFSLFlBQVlRLFFBQVE7UUFDbkQsT0FBTztZQUFFQTtZQUFPUjtZQUFXVztZQUFTRTtZQUFTQztRQUFlO0lBQzlEO0lBRUEsT0FBTztRQUNMbEM7UUFDQUs7UUFDQUU7UUFDQUs7UUFDQVM7UUFDQUM7UUFDQUM7UUFDQUU7UUFDQUU7UUFDQVEsY0FBYyxJQUFNL0IsU0FBU2xCO0lBQy9CO0FBQ0YsRUFFQSwyQ0FBMkM7Q0FDM0MseUJBQXlCO0NBQ3pCLDJDQUEyQztDQUMzQyx1Q0FBdUM7Q0FFdkMsOEJBQThCO0NBQzlCLDREQUE0RDtDQUM1RCxvRUFBb0U7Q0FDcEUsa0VBQWtFO0NBQ2xFLHdFQUF3RTtDQUV4RSxtQ0FBbUM7Q0FDbkMsMkVBQTJFO0NBRTNFLDRCQUE0QjtDQUM1Qix5REFBeUQ7Q0FDekQsMERBQTBEO0NBRTFELDJCQUEyQjtDQUMzQixnRUFBZ0U7Q0FDaEUsaUVBQWlFO0NBRWpFLDJDQUEyQztDQUMzQyxnQkFBZ0I7Q0FDaEIsMkNBQTJDO0NBQzNDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQTZCQSIsInNvdXJjZXMiOlsiL1VzZXJzL3JvbmlsL0Rlc2t0b3AvVG9Eb0xpc3QvZnJvbnRlbmQvaG9va3MvdXNlVGFza3NBUEkudHMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuLy8gQVBJIElOVEVHUkFUSU9OIC0gRU5BQkxFRFxuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuLy8gVGhpcyBmaWxlIHByb3ZpZGVzIGJhY2tlbmQgQVBJIGludGVncmF0aW9uIGZvciB0YXNrIHBlcnNpc3RlbmNlXG4vLyBUYXNrcyBhcmUgbm93IHN0b3JlZCBpbiBNb25nb0RCIGluc3RlYWQgb2YgbG9jYWxTdG9yYWdlXG5cbmltcG9ydCB7IHVzZVN0YXRlLCB1c2VFZmZlY3QgfSBmcm9tIFwicmVhY3RcIlxuaW1wb3J0IHR5cGUgeyBUYXNrIH0gZnJvbSBcIkAvY29tcG9uZW50cy9UYXNrQ2FyZFwiXG5cbmNvbnN0IFRBU0tTX0tFWSA9IFwidGFza01hbmFnZXJUYXNrc1wiXG5cbmZ1bmN0aW9uIGxvYWRUYXNrc0Zyb21TdG9yYWdlKCk6IFRhc2tbXSB7XG4gIHRyeSB7XG4gICAgY29uc3QgZGF0YSA9IGxvY2FsU3RvcmFnZS5nZXRJdGVtKFRBU0tTX0tFWSlcbiAgICBpZiAoIWRhdGEpIHJldHVybiBbXVxuICAgIGNvbnN0IHBhcnNlZCA9IEpTT04ucGFyc2UoZGF0YSlcbiAgICByZXR1cm4gcGFyc2VkLm1hcCgodGFzazogYW55KSA9PiAoe1xuICAgICAgLi4udGFzayxcbiAgICAgIGNyZWF0ZWRBdDogbmV3IERhdGUodGFzay5jcmVhdGVkQXQpLFxuICAgICAgZHVlRGF0ZTogdGFzay5kdWVEYXRlID8gbmV3IERhdGUodGFzay5kdWVEYXRlKSA6IHVuZGVmaW5lZCxcbiAgICB9KSlcbiAgfSBjYXRjaCB7XG4gICAgcmV0dXJuIFtdXG4gIH1cbn1cblxuZnVuY3Rpb24gc2F2ZVRhc2tzVG9TdG9yYWdlKHRhc2tzOiBUYXNrW10pIHtcbiAgbG9jYWxTdG9yYWdlLnNldEl0ZW0oVEFTS1NfS0VZLCBKU09OLnN0cmluZ2lmeSh0YXNrcykpXG59XG5cbmV4cG9ydCBmdW5jdGlvbiB1c2VUYXNrcygpIHtcbiAgY29uc3QgW3Rhc2tzLCBzZXRUYXNrc10gPSB1c2VTdGF0ZTxUYXNrW10+KFtdKVxuICBjb25zdCBbbG9hZGluZywgc2V0TG9hZGluZ10gPSB1c2VTdGF0ZSh0cnVlKVxuICBjb25zdCBbZXJyb3IsIHNldEVycm9yXSA9IHVzZVN0YXRlPHN0cmluZyB8IG51bGw+KG51bGwpXG5cbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBzZXRMb2FkaW5nKHRydWUpXG4gICAgdHJ5IHtcbiAgICAgIHNldFRhc2tzKGxvYWRUYXNrc0Zyb21TdG9yYWdlKCkpXG4gICAgICBzZXRFcnJvcihudWxsKVxuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgc2V0RXJyb3IoXCJGYWlsZWQgdG8gbG9hZCB0YXNrc1wiKVxuICAgIH0gZmluYWxseSB7XG4gICAgICBzZXRMb2FkaW5nKGZhbHNlKVxuICAgIH1cbiAgfSwgW10pXG5cbiAgY29uc3Qgc2F2ZSA9IChuZXdUYXNrczogVGFza1tdKSA9PiB7XG4gICAgc2V0VGFza3MobmV3VGFza3MpXG4gICAgc2F2ZVRhc2tzVG9TdG9yYWdlKG5ld1Rhc2tzKVxuICB9XG5cbiAgY29uc3QgYWRkVGFzayA9ICh0YXNrRGF0YTogT21pdDxUYXNrLCBcImlkXCIgfCBcImNyZWF0ZWRBdFwiIHwgXCJjb21wbGV0ZWRcIj4pID0+IHtcbiAgICBjb25zdCBuZXdUYXNrOiBUYXNrID0ge1xuICAgICAgLi4udGFza0RhdGEsXG4gICAgICBpZDogTWF0aC5yYW5kb20oKS50b1N0cmluZygzNikuc2xpY2UoMiksXG4gICAgICBjcmVhdGVkQXQ6IG5ldyBEYXRlKCksXG4gICAgICBjb21wbGV0ZWQ6IGZhbHNlLFxuICAgIH1cbiAgICBzYXZlKFtuZXdUYXNrLCAuLi50YXNrc10pXG4gICAgcmV0dXJuIG5ld1Rhc2suaWRcbiAgfVxuXG4gIGNvbnN0IHVwZGF0ZVRhc2sgPSAoaWQ6IHN0cmluZywgdGFza0RhdGE6IFBhcnRpYWw8T21pdDxUYXNrLCBcImlkXCIgfCBcImNyZWF0ZWRBdFwiIHwgXCJjb21wbGV0ZWRcIj4+KSA9PiB7XG4gICAgc2F2ZSh0YXNrcy5tYXAodGFzayA9PiB0YXNrLmlkID09PSBpZCA/IHsgLi4udGFzaywgLi4udGFza0RhdGEgfSA6IHRhc2spKVxuICB9XG5cbiAgY29uc3QgdG9nZ2xlQ29tcGxldGUgPSAoaWQ6IHN0cmluZykgPT4ge1xuICAgIHNhdmUodGFza3MubWFwKHRhc2sgPT4gdGFzay5pZCA9PT0gaWQgPyB7IC4uLnRhc2ssIGNvbXBsZXRlZDogIXRhc2suY29tcGxldGVkIH0gOiB0YXNrKSlcbiAgfVxuXG4gIGNvbnN0IGRlbGV0ZVRhc2sgPSAoaWQ6IHN0cmluZykgPT4ge1xuICAgIHNhdmUodGFza3MuZmlsdGVyKHRhc2sgPT4gdGFzay5pZCAhPT0gaWQpKVxuICB9XG5cbiAgY29uc3QgZ2V0VGFzayA9IChpZDogc3RyaW5nKSA9PiB0YXNrcy5maW5kKHRhc2sgPT4gdGFzay5pZCA9PT0gaWQpXG5cbiAgY29uc3QgZ2V0U3RhdHMgPSAoKSA9PiB7XG4gICAgY29uc3QgdG90YWwgPSB0YXNrcy5sZW5ndGhcbiAgICBjb25zdCBjb21wbGV0ZWQgPSB0YXNrcy5maWx0ZXIodCA9PiB0LmNvbXBsZXRlZCkubGVuZ3RoXG4gICAgY29uc3QgcGVuZGluZyA9IHRhc2tzLmZpbHRlcih0ID0+ICF0LmNvbXBsZXRlZCAmJiB0LnN0YXR1cyAhPT0gXCJEb25lXCIpLmxlbmd0aFxuICAgIGNvbnN0IG92ZXJkdWUgPSB0YXNrcy5maWx0ZXIodCA9PiAhdC5jb21wbGV0ZWQgJiYgdC5kdWVEYXRlICYmIHQuZHVlRGF0ZSA8IG5ldyBEYXRlKCkpLmxlbmd0aFxuICAgIGNvbnN0IGNvbXBsZXRpb25SYXRlID0gdG90YWwgPyBjb21wbGV0ZWQgLyB0b3RhbCA6IDBcbiAgICByZXR1cm4geyB0b3RhbCwgY29tcGxldGVkLCBwZW5kaW5nLCBvdmVyZHVlLCBjb21wbGV0aW9uUmF0ZSB9XG4gIH1cblxuICByZXR1cm4ge1xuICAgIHRhc2tzLFxuICAgIGxvYWRpbmcsXG4gICAgZXJyb3IsXG4gICAgYWRkVGFzayxcbiAgICB1cGRhdGVUYXNrLFxuICAgIHRvZ2dsZUNvbXBsZXRlLFxuICAgIGRlbGV0ZVRhc2ssXG4gICAgZ2V0VGFzayxcbiAgICBnZXRTdGF0cyxcbiAgICByZWZyZXNoVGFza3M6ICgpID0+IHNldFRhc2tzKGxvYWRUYXNrc0Zyb21TdG9yYWdlKCkpLFxuICB9XG59XG5cbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbi8vIE1JR1JBVElPTiBJTlNUUlVDVElPTlNcbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbi8vIFRvIG1pZ3JhdGUgZnJvbSBsb2NhbFN0b3JhZ2UgdG8gQVBJOlxuXG4vLyAxLiBVbmNvbW1lbnQgdGhlIGNvZGUgYWJvdmVcbi8vIDIuIFJlcGxhY2UgdGhlIGV4aXN0aW5nIHVzZVRhc2tzIGhvb2sgaW4geW91ciBjb21wb25lbnRzOlxuLy8gICAgLSBJbiBhcHAvdGFza3MvcGFnZS50c3g6IFJlcGxhY2UgdXNlVGFza3MoKSB3aXRoIHVzZVRhc2tzQVBJKClcbi8vICAgIC0gSW4gYXBwL2FkZC9wYWdlLnRzeDogUmVwbGFjZSB1c2VUYXNrcygpIHdpdGggdXNlVGFza3NBUEkoKVxuLy8gICAgLSBJbiBhcHAvZWRpdC9baWRdL3BhZ2UudHN4OiBSZXBsYWNlIHVzZVRhc2tzKCkgd2l0aCB1c2VUYXNrc0FQSSgpXG5cbi8vIDMuIFVwZGF0ZSBlbnZpcm9ubWVudCB2YXJpYWJsZXM6XG4vLyAgICAtIEFkZCBORVhUX1BVQkxJQ19BUElfVVJMPWh0dHA6Ly9sb2NhbGhvc3Q6NjkwMC9hcGkgdG8geW91ciAuZW52IGZpbGVcblxuLy8gNC4gSGFuZGxlIGxvYWRpbmcgc3RhdGVzOlxuLy8gICAgLSBUaGUgQVBJIHZlcnNpb24gaW5jbHVkZXMgbG9hZGluZyBhbmQgZXJyb3Igc3RhdGVzXG4vLyAgICAtIEFkZCBsb2FkaW5nIHNwaW5uZXJzIGFuZCBlcnJvciBtZXNzYWdlcyB0byB5b3VyIFVJXG5cbi8vIDUuIFRlc3QgdGhlIGludGVncmF0aW9uOlxuLy8gICAgLSBTdGFydCBib3RoIGZyb250ZW5kIGFuZCBiYWNrZW5kOiBucG0gcnVuIGRldiAoZnJvbSByb290KVxuLy8gICAgLSBWZXJpZnkgdGFza3MgYXJlIHNhdmVkIHRvIE1vbmdvREIgaW5zdGVhZCBvZiBsb2NhbFN0b3JhZ2VcblxuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuLy8gRVhBTVBMRSBVU0FHRVxuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuLypcbmZ1bmN0aW9uIFRhc2tzUGFnZSgpIHtcbiAgY29uc3QgeyBcbiAgICB0YXNrcywgXG4gICAgbG9hZGluZywgXG4gICAgZXJyb3IsIFxuICAgIGFkZFRhc2ssIFxuICAgIHVwZGF0ZVRhc2ssIFxuICAgIHRvZ2dsZUNvbXBsZXRlLCBcbiAgICBkZWxldGVUYXNrIFxuICB9ID0gdXNlVGFza3NBUEkoKVxuXG4gIGlmIChsb2FkaW5nKSByZXR1cm4gPGRpdj5Mb2FkaW5nIHRhc2tzLi4uPC9kaXY+XG4gIGlmIChlcnJvcikgcmV0dXJuIDxkaXY+RXJyb3I6IHtlcnJvcn08L2Rpdj5cblxuICByZXR1cm4gKFxuICAgIDxkaXY+XG4gICAgICB7dGFza3MubWFwKHRhc2sgPT4gKFxuICAgICAgICA8VGFza0NhcmRcbiAgICAgICAgICBrZXk9e3Rhc2suaWR9XG4gICAgICAgICAgdGFzaz17dGFza31cbiAgICAgICAgICBvblRvZ2dsZUNvbXBsZXRlPXt0b2dnbGVDb21wbGV0ZX1cbiAgICAgICAgICBvbkVkaXQ9eyhpZCkgPT4gcm91dGVyLnB1c2goYC9lZGl0LyR7aWR9YCl9XG4gICAgICAgICAgb25EZWxldGU9e2RlbGV0ZVRhc2t9XG4gICAgICAgIC8+XG4gICAgICApKX1cbiAgICA8L2Rpdj5cbiAgKVxufVxuKi8gIl0sIm5hbWVzIjpbInVzZVN0YXRlIiwidXNlRWZmZWN0IiwiVEFTS1NfS0VZIiwibG9hZFRhc2tzRnJvbVN0b3JhZ2UiLCJkYXRhIiwibG9jYWxTdG9yYWdlIiwiZ2V0SXRlbSIsInBhcnNlZCIsIkpTT04iLCJwYXJzZSIsIm1hcCIsInRhc2siLCJjcmVhdGVkQXQiLCJEYXRlIiwiZHVlRGF0ZSIsInVuZGVmaW5lZCIsInNhdmVUYXNrc1RvU3RvcmFnZSIsInRhc2tzIiwic2V0SXRlbSIsInN0cmluZ2lmeSIsInVzZVRhc2tzIiwic2V0VGFza3MiLCJsb2FkaW5nIiwic2V0TG9hZGluZyIsImVycm9yIiwic2V0RXJyb3IiLCJlcnIiLCJzYXZlIiwibmV3VGFza3MiLCJhZGRUYXNrIiwidGFza0RhdGEiLCJuZXdUYXNrIiwiaWQiLCJNYXRoIiwicmFuZG9tIiwidG9TdHJpbmciLCJzbGljZSIsImNvbXBsZXRlZCIsInVwZGF0ZVRhc2siLCJ0b2dnbGVDb21wbGV0ZSIsImRlbGV0ZVRhc2siLCJmaWx0ZXIiLCJnZXRUYXNrIiwiZmluZCIsImdldFN0YXRzIiwidG90YWwiLCJsZW5ndGgiLCJ0IiwicGVuZGluZyIsInN0YXR1cyIsIm92ZXJkdWUiLCJjb21wbGV0aW9uUmF0ZSIsInJlZnJlc2hUYXNrcyJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./hooks/useTasksAPI.ts\n"));

/***/ })

});